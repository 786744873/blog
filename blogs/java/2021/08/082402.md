---
title: 设计模式之工厂模式
date: 2021-08-24
sidebar: auto
categories:
 - java
tags:
 - 设计模式
 - 创建型模式
---

## 简单工厂模式✨

工厂模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。

按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是**简单工厂模式、工厂方法模式和抽象工厂模式**。

我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。

**在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。**

简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。

**简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。**

## 简单工厂模式的优点🧨

1. **工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。**
2. **客户端无需知道所创建具体产品的类名，只需知道参数即可。**
3. **也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。**

## 简单工厂模式的缺点🎋

1. **简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。**
2. **使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度**
3. **系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂**
4. **简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。**

## 简单工厂模式的应用场景🎋

**对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。**

## **代码实现🎟**
### 1、抽象产品
```java
/**
 * Product 接口描述
 *
 * @version 1.0.0
 * @Description: 抽象产品
 * @author: LiJunYi
 * @create: 2021/5/27 15:35
 */
public interface Product
{
    String create();
}
```
### 2、具体产品
```java
/**
 * @version 1.0.0
 * @className: CupProduct
 * @description: 杯子产品
 * @author: LiJunYi
 * @create: 2021/5/27 15:36
 */
public class CupProduct implements Product
{

    @Override
    public String create() {
        System.out.println("杯子产品创建");
        return "杯子产品创建";
    }
}

/**
 * @version 1.0.0
 * @className: CupProduct
 * @description: 毛巾产品
 * @author: LiJunYi
 * @create: 2021/5/27 15:36
 */
public class TowelProduct implements Product
{

    @Override
    public String create() {
        System.out.println("毛巾产品创建");
        return "毛巾产品创建";
    }
}
```

### 3、简单工厂模式

```java
/**
 * @version 1.0.0
 * @className: EasyProductFactory
 * @description: 简单工厂模式
 * @author: LiJunYi
 * @create: 2021/5/27 15:37
 */
public class EasyProductFactory
{
    public static Product createProduct(String name)
    {
        if ("CupProduct".equals(name))
        {
            return new CupProduct();
        }else if ("TowelProduct".equals(name))
        {
            return new TowelProduct();
        }else {
            return null;
        }
    }

    public static void main(String[] args) {
        Product concreteProduct1 = EasyProductFactory.createProduct("CupProduct");
        Product concreteProduct2 = EasyProductFactory.createProduct("TowelProduct");
        System.out.println(concreteProduct1.create());
        System.out.println(concreteProduct2.create());
    }
}
```

## 工厂方法模式✨

**简单工厂模式违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。**

这个其实和简单工厂模式差不太多，就是将工厂继续拆分，比如说刚刚EasyProductFactory是一个总工厂，我们现在拆分成CupFactory和TowelFactory分别生产杯子和毛巾。某个工厂内部可以根据需求生产不同的产品。

## 工厂方法模式的优点🧨

- **用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。**
- **灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。**
- **典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。**

## 工厂方法模式的缺点🎋

- **类的个数容易过多，增加复杂度**
- **增加了系统的抽象性和理解难度**
- **抽象产品只能生产一种产品，此弊端可使用[抽象工厂模式]解决。**

## 工厂方法模式的应用场景🎋

- **客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。**
- **创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。**
- **客户不关心创建产品的细节，只关心产品的品牌**

## 工厂方法模式的结构与实现🕳

**工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。**

**工厂方法模式的主要角色如下。**

1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
2. 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
4. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

![page](http://c.biancheng.net/uploads/allimg/181114/3-1Q114135A2M3.gif)

## **代码实现🎟**

### 1、抽象工厂

```java
/**
 * ProductFactory 接口描述
 *
 * @version 1.0.0
 * @Description: 抽象工厂
 * @author: LiJunYi
 * @create: 2021/5/27 15:58
 */
public interface ProductFactory
{
    Product create();
}

```

### 2、具体工厂

```java
/**
 * @version 1.0.0
 * @className: CupFactory
 * @description: 具体工厂1
 * @author: LiJunYi
 * @create: 2021/5/27 15:59
 */
public class CupFactory implements ProductFactory
{

    @Override
    public Product create() {
        System.out.println("杯子工厂生产-> 生产杯子...");
        return new CupProduct();
    }
}

/**
 * @version 1.0.0
 * @className: TowelFactory
 * @description: 具体工厂2
 * @author: LiJunYi
 * @create: 2021/5/27 16:00
 */
public class TowelFactory implements ProductFactory
{

    @Override
    public Product create() {
        System.out.println("毛巾工厂生产-> 生产毛巾...");
        return new TowelProduct();
    }
}

```

### 3、工厂模式

```java
/**
 * @version 1.0.0
 * @className: AbstractFactoryTest
 * @description: 工厂模式
 * @author: LiJunYi
 * @create: 2021/5/27 16:06
 */
public class AbstractFactoryTest
{
    public static void main(String[] args) {
        try {
            ProductFactory productFactory = new CupFactory();
            Product product = productFactory.create();
            product.create();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

## 抽象工厂模式✨

**工厂方法模式**   中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机等。

同种类称为同等级，也就是说：**工厂方法模式**   只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调等。

**抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族**

![page](http://c.biancheng.net/uploads/allimg/181114/3-1Q1141559151S.gif)

## 抽象工厂模式的定义🧨

**抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。**

抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。

**使用抽象工厂模式一般要满足以下条件。**

- 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。
- 系统一次只可能消费其中某一族产品，即同族的产品一起使用。

**抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。**

- 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
- 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。
- 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。


其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。

## 模式的结构与实现🕳

**抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。**

**抽象工厂模式的主要角色如下。**

1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。
2. 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
4. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。

## **代码实现🎟**

### 1、抽象工厂

```java
/**
 * AbstractFactory 接口描述
 *
 * @version 1.0.0
 * @Description: 抽象工厂：提供了产品的生成方法。
 * @author: LiJunYi
 * @create: 2021/5/27 16:24
 */
public interface AbstractFactory
{
    /**
     * 生产杯子
     *
     * @return {@link Product}
     */
    Product createCup();

    /**
     * 生产鞋子
     *
     * @return {@link Product2}
     */
    Product2 createShoes();
}

```

### 2、具体工厂

```java
/**
 * @version 1.0.0
 * @className: CupAndShoesFactory  具体工厂：实现了产品的生成方法。
 * @description: 杯子和鞋子类产品生产工厂(不同等级)
 * @author: LiJunYi
 * @create: 2021/5/27 16:31
 */
public class CupAndShoesFactory implements AbstractFactory
{


    /**
     * 生产杯子
     *
     * @return {@link Product}
     */
    @Override
    public Product createCup() {
        System.out.println("具体工厂（杯子）创建->");
        return new CupProduct();
    }

    /**
     * 生产鞋子
     *
     * @return {@link Product2}
     */
    @Override
    public Product2 createShoes() {
        System.out.println("具体工厂（鞋子）创建->");
        return new ShoesProduct();
    }
}

```

### 3、抽象产品

```java
/**
 * Product2 接口描述
 *
 * @version 1.0.0
 * @Description: 抽象产品2
 * @author: LiJunYi
 * @create: 2021/5/27 16:27
 */
public interface Product2
{
    String create();
}

```

### 4、具体产品

```java
/**
 * @version 1.0.0
 * @className: ShoesProduct
 * @description: 鞋类产品
 * @author: LiJunYi
 * @create: 2021/5/27 16:32
 */
public class ShoesProduct implements Product2
{
    @Override
    public String create() {
        System.out.println("鞋子产品生产");
        return "鞋子产品生产";
    }
}

```

### 5、测试类

```java
/**
 * @version 1.0.0
 * @className: AbstractFactoryMain
 * @description:
 * @author: LiJunYi
 * @create: 2021/5/27 16:38
 */
public class AbstractFactoryMain
{
    public static void main(String[] args) {
        CupProduct cupProduct;
        ShoesProduct shoesProduct;
        AbstractFactory abstractFactory = new CupAndShoesFactory();
        cupProduct = (CupProduct) abstractFactory.createCup();
        shoesProduct = (ShoesProduct) abstractFactory.createShoes();
        cupProduct.create();
        shoesProduct.create();
    }

}

```

