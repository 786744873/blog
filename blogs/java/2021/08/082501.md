---
title: 设计模式之迭代器模式
date: 2021-08-25
sidebar: auto
categories:
 - java
tags:
 - 设计模式
 - 行为型模式
---

## 迭代器模式的定义与特点✨

**迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式.**

```markdown
# 其主要优点如下。

1. 访问一个聚合对象的内容而无须暴露它的内部表示。
2. 遍历任务交由迭代器完成，这简化了聚合类。
3. 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。
4. 增加新的聚合类和迭代器类都很方便，无须修改原有代码。
5. 封装性良好，为遍历不同的聚合结构提供一个统一的接口。


# 其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。

在日常开发中，我们几乎不会自己写迭代器。除非需要定制一个自己实现的数据结构对应的迭代器，否则，开源框架提供的 API 完全够用。
```

## 迭代器模式的结构与实现🎐

迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。现在我们来分析其基本结构与实现方法。

## 迭代器模式的结构🎋

**迭代器模式主要包含以下角色。**

1. 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。
2. 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。
3. 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。
4. 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。

## 代码效果🎟

### 1、抽象聚合

```java
/**
 * @version 1.0.0
 * @className: Aggregate
 * @description: 抽象聚合
 * @author: LiJunYi
 * @create: 2021/5/31 16:20
 */
public interface Aggregate
{
    /**
     * 添加
     *
     * @param obj obj
     */
    public void add(Object obj);

    /**
     * 删除
     *
     * @param obj obj
     */
    public void remove(Object obj);

    /**
     * 得到迭代器
     *
     * @return {@link Iterator}
     */
    public Iterator getIterator();
}
```

### 2、具体聚合

```java
/**
 * @version 1.0.0
 * @className: ConcreteAggregate
 * @description: 具体聚合
 * @author: LiJunYi
 * @create: 2021/5/31 16:22
 */
public class ConcreteAggregate implements  Aggregate
{
    private List<Object> list = new ArrayList<>();

    @Override
    public void add(Object obj) {
        list.add(obj);
    }

    @Override
    public void remove(Object obj) {
        list.remove(obj);
    }

    @Override
    public Iterator getIterator() {
        return (new ConcreteIterator(list));
    }
}
```

### 3、抽象迭代器

```java
/**
 * Iterator 接口描述
 *
 * @version 1.0.0
 * @Description: 抽象迭代器
 * @author: LiJunYi
 * @create: 2021/5/31 16:21
 */
public interface Iterator
{
    /**
     * 第一个
     *
     * @return {@link Object}
     */
    Object first();

    /**
     * 下一个
     *
     * @return {@link Object}
     */
    Object next();

    /**
     * 有下一个
     *
     * @return boolean
     */
    boolean hasNext();
}
```

### 4、具体迭代器

```java
/**
 * @version 1.0.0
 * @className: ConcreteIterator
 * @description: 具体迭代器
 * @author: LiJunYi
 * @create: 2021/5/31 16:22
 */
public class ConcreteIterator implements Iterator
{
    private List<Object> list = null;
    private int index = -1;

    public ConcreteIterator(List<Object> list) {
        this.list = list;
    }

    @Override
    public Object first() {
        index = 0;
        Object obj = list.get(index);
        return obj;
    }

    @Override
    public Object next() {
        Object obj = null;
        if (this.hasNext()) {
            obj = list.get(++index);
        }
        return obj;
    }

    @Override
    public boolean hasNext() {
        if (index < list.size() - 1) {
            return true;
        } else {
            return false;
        }
    }
}
```

### 5、迭代器测试类

```java
/**
 * @version 1.0.0
 * @className: IteratorPattern
 * @description: 迭代器模式测试
 * @author: LiJunYi
 * @create: 2021/5/31 16:24
 */
public class IteratorPattern
{
    public static void main(String[] args) {
        Aggregate ag = new ConcreteAggregate();
        ag.add("中山大学");
        ag.add("华南理工");
        ag.add("韶关学院");
        System.out.print("聚合的内容有：");
        Iterator it = ag.getIterator();
        while (it.hasNext()) {
            Object ob = it.next();
            System.out.print(ob.toString() + "\t");
        }
        Object ob = it.first();
        System.out.println("\nFirst：" + ob.toString());
    }
}
```
